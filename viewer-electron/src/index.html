<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Multi‑Viewer</title>
  <style>
    body { font-family: sans-serif; margin: 0; display: flex; height: 100vh; }
    #left { width: 320px; padding: 12px; border-right: 1px solid #ddd; box-sizing: border-box; }
    #grid { flex: 1; display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); grid-auto-rows: 180px; gap: 8px; padding: 8px; background: #111; }
    video { width: 100%; height: 100%; object-fit: contain; background: #000; border-radius: 6px; }
    .tile { position: relative; }
    .label { position: absolute; left: 8px; top: 8px; background: rgba(0,0,0,.6); color: #fff; padding: 2px 6px; border-radius: 4px; font-size: 12px; }
    input, button { width: 100%; margin-bottom: 8px; padding: 8px; }
  </style>
</head>
<body>
  <div id="left">
    <h3>Подключение</h3>
    <input id="signalUrl" placeholder="ws://IP:8080">
    <input id="room" placeholder="room">
    <button id="connectBtn">Подключиться</button>
    <div id="status"></div>
  </div>
  <div id="grid"></div>
  <script type="module">
    import { DEFAULT_SIGNAL_URL, DEFAULT_ROOM, RTC_CONFIG } from './config.js';
    const grid = document.getElementById('grid');
    const status = document.getElementById('status');
    const urlInput = document.getElementById('signalUrl');
    const roomInput = document.getElementById('room');
    urlInput.value = DEFAULT_SIGNAL_URL;
    roomInput.value = DEFAULT_ROOM;

    let ws, clientId;
    const peers = new Map(); // peerId => RTCPeerConnection
    const streams = new Map(); // peerId => MediaStream
    const tiles = new Map(); // peerId => HTMLElement

    function addTile(peerId, stream) {
      let tile = tiles.get(peerId);
      if (!tile) {
        tile = document.createElement('div');
        tile.className = 'tile';
        const v = document.createElement('video');
        v.autoplay = true; v.playsInline = true; v.muted = true;
        const label = document.createElement('div');
        label.className = 'label'; label.textContent = peerId.slice(0,8);
        tile.appendChild(v); tile.appendChild(label);
        grid.appendChild(tile);
        tiles.set(peerId, tile);
      }
      const video = tile.querySelector('video');
      if (video.srcObject !== stream) video.srcObject = stream;
    }

    function removeTile(peerId) {
      const tile = tiles.get(peerId);
      if (tile) { tile.remove(); tiles.delete(peerId); }
    }

    function connect() {
      ws = new WebSocket(urlInput.value);
      ws.onopen = () => {
        status.textContent = 'WebSocket connected';
        ws.send(JSON.stringify({ type: 'join', roomId: roomInput.value }));
      };
      ws.onmessage = async (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'joined') {
          clientId = msg.clientId;
          status.textContent = `Joined as ${clientId}`;
        }
        if (msg.type === 'peer-join') {
          // создадим пассивное соединение (viewer будет принимать)
          const peerId = msg.clientId;
          const pc = new RTCPeerConnection(RTC_CONFIG);
          peers.set(peerId, pc);
          pc.ontrack = (ev) => {
            const stream = ev.streams[0];
            streams.set(peerId, stream);
            addTile(peerId, stream);
          };
          // сразу шлем offer-запрос "recvonly"
          const transceiver = pc.addTransceiver('video', { direction: 'recvonly' });
          // Дожидаемся ICE и шлем SDP
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          ws.send(JSON.stringify({ type: 'signal', roomId: roomInput.value, targetId: peerId, payload: { sdp: pc.localDescription } }));
        }
        if (msg.type === 'signal') {
          const from = msg.fromId;
          const payload = msg.payload;
          let pc = peers.get(from);
          if (!pc) {
            pc = new RTCPeerConnection(RTC_CONFIG);
            peers.set(from, pc);
            pc.ontrack = (ev) => {
              const stream = ev.streams[0];
              streams.set(from, stream);
              addTile(from, stream);
            };
          }
          if (payload.sdp) {
            const desc = new RTCSessionDescription(payload.sdp);
            await pc.setRemoteDescription(desc);
            if (desc.type === 'offer') {
              const answer = await pc.createAnswer();
              await pc.setLocalDescription(answer);
              ws.send(JSON.stringify({ type: 'signal', roomId: roomInput.value, targetId: from, payload: { sdp: pc.localDescription } }));
            }
          } else if (payload.candidate) {
            try { await pc.addIceCandidate(payload.candidate); } catch {}
          }
          pc.onicecandidate = (ev) => {
            if (ev.candidate) {
              ws.send(JSON.stringify({ type: 'signal', roomId: roomInput.value, targetId: from, payload: { candidate: ev.candidate } }));
            }
          };
        }
        if (msg.type === 'peer-leave') {
          const peerId = msg.clientId;
          const pc = peers.get(peerId);
          if (pc) { pc.close(); peers.delete(peerId); }
          removeTile(peerId);
        }
      };
      ws.onclose = () => { status.textContent = 'WebSocket closed'; };
    }

    document.getElementById('connectBtn').onclick = () => connect();
  </script>
</body>
</html>